<!DOCTYPE html>
<!--
Created using JS Bin
http://jsbin.com

Copyright (c) 2018 by anonymous (http://jsbin.com/hategiyowa/1/edit)

Released under the MIT license: http://jsbin.mit-license.org
-->
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <link href="https://fonts.google.com/?selection.family=IBM+Plex+Serif|Open+Sans+Condensed:300|Oswald|Slabo+27px" rel="stylesheet">
  
  <title>Учитесь писать код без for</title>
<style id="jsbin-css">


@media screen and (max-width: 320px) {
  .wrapper {margin: 0 10px;}
  h1 {font-size: 20px;}
  h3 {font-size: 14px}
  p,ol {font-size: 13px;}
  blockquote{font-size: 12px;}
  .start_img {width: 270px;}
  .img_book {width: 70px; margin-right: 5px;}
}

@media screen and (min-width: 321px) and (max-width: 480px) {
  .wrapper {margin: 0 20px;}
  h1 {font-size: 24px;}
  h3 {font-size: 19px}
  p,ol {font-size: 15px;}
  blockquote{font-size: 12px;}
  .start_img {width: 400px;}
  .img_book {width: 80px; margin-right: 10px;}
}

@media screen and (min-width: 481px) and (max-width: 640px) {
  .wrapper {margin: 0 40px;}
  h1 {font-size: 28px;}
  h3 {font-size: 20px}
  blockquote{font-size: 15px;}
  .img_book {width: 100px; margin-right: 10px;}
}

@media screen and (min-width: 641px) and (max-width: 800px) {
  .wrapper {margin: 0 80px;}
  h3 {font-size: 22px;}
  p,ol {font-size: 19px;}
  blockquote{font-size: 16px;}
  .img_book {width: 140px; margin-right: 10px;}
}

@media screen and (min-width: 801px) and (max-width: 1024px) {
  .wrapper {margin: 0 140px;}
  h3 {font-size: 22px;}
  p,ol {font-size: 19px;}
  blockquote{font-size: 16px;}
  .img_book {width: 140px; margin-right: 10px;}
}

@media screen and (min-width: 1025px) and (max-width: 1280px) {
  .wrapper {margin: 0 240px;}
  h3 {font-size: 22px;}
  p,ol {font-size: 19px;}
  blockquote{font-size: 16px;}
  .img_book {width: 140px; margin-right: 10px;}
}

@media screen and (min-width: 1281px) and (max-width: 1920px) {
  .wrapper {margin: 0 300px;}
  h1 {font-size: 34px;}
  h3 {font-size: 22px;}
  p,ol {font-size: 20px;}
  blockquote{font-size: 17px;}
  .img_book {width: 180px; margin-right: 10px;}
}

body {
  font-family: 'Georgia';
}

pre {
  margin: 0;
  white-space: pre-wrap;
  font-family: 'Space Mono', monospace;
}

blockquote {
  background-color: #aaaabb;
  padding: 5px 10px;
  border-left: 1px solid #919191;
  border-radius: 4px;
}

li > blockquote {
  margin: 0;
}

span.quote::before {
  content: '"';
}

span.quote::after {
  content: '"';
}

a {
  text-decoration: none;
}

a:link {
  color: #FF8C00;
}

a:visited {
    color: #900060; /* Цвет посещенных ссылок */
   }

a:hover {
  background: #FFA07A;
}

a:visited {
  color: grey;
}

a:active {
  background: #F0E68C;
}

.first_letter::first-letter, .first_line::first-line {
  color: #00FA9A;
}

.first_line_tit::first-line {
  color: #FA8072;
}

.select::selection {
  background: #20B2AA;
  color: white;
}

.positioner::after {
  content: "";
  display: table;
  clear: both;
}
</style>
</head>
<body>
  <div class="wrapper">
    <h1 class="select first_line_tit">Учитесь писать код без for</h1>
    <p>Зачем писать код с <b>for</b>, если можно этого не делать? Аргументируем, почему.</p>
    <img class="start_img" src="https://proglib.io/wp-content/uploads/-000//1/1*mK8QWFCWgCjh5dWMKgqGPQ.png">
    <p><a href="https://proglib.io/p/without-if/">Также читайте статью о написание кода без if</a></p>
    <h3 class="select first_letter">О чем это?</h3>
    <p class="select">
      В предыдущей статье приводилось несколько задач, которые нужно было решить без условных операторов. В этой, задач будет немного больше, на решение без циклов.
    </p>
    <p class="select">
      Под циклами мы имеем в виду императивные циклы наподобие <b>for, for … in, for … of, while, do … while</b>. Все они работают по одному принципу — императивный стиль выполнения операций. Альтернативой ему является декларативный стиль.
    </p>
    <h3 class="select first_letter">Императивность vs декларативность</h3>
    <p class="select">
      <span class="quote select">Это весьма обширная тема</span>, но в двух словах разницу можно описать так:
      <ul>
        <li class="select">Императивный стиль говорит, “как” …</li>
        <li class="select">Декларативный стиль показывает, “что” …</li>
      </ul>
    </p>
    <h3 class="select first_letter">Какая между ними разница?</h3>
    <p class="select">
      Императивный подход представляет последовательность действий. Сделать то-то, затем это, после что-то ещё. Например: пройтись последовательно по списку чисел, прибавить величину каждого к вычисляющейся сумме.
    </p>
    <p class="select">
      Декларативный подход показывает, что у нас есть и что нам нужно получить. <i>Например</i>: дан список чисел, нужно получить их сумму.
    </p>
    <p class="select">
      Императивный язык ближе для компьютера, поскольку выполнять инструкции — и есть то самое, для чего они спроектированы. Декларативный стиль ближе к тому, как мы думаем и интуитивно хотим программировать. Компьютер, сделай это, пожалуйста. Как-нибудь!
    </p>
    <p class="select">
      К счастью, языки программирования уже предлагают нам средства для декларативного описания императивных инструкций. В этой статье мы сконцентрируемся на декларативном задании циклов.
    </p>  
    <p class="select">
      Сразу скажем, что не нужно искать единственно верный способ программирования. Любая нетривиальная программа почти наверняка должна включать в себя оба подхода. Лучше всего — просто их знать и уверенно пользоваться обоими.
    </p> 
    <h3 class="select first_letter">Immutability — неизменяемость</h3>
    <p class="select">
      Избегать циклы стоит не только для того, чтобы приобщиться к декларативному стилю. Важный момент здесь — относиться к данным как к immutable.
    </p>
    <p class="select">
      Неизменяемость данных — ещё одна большая тема, но в глобальном смысле суть — не изменять данные в переменных и свойствах объектов для представления состояния приложения. Вместо того, состояние сохраняется в фазах между вызовами функций. Функции вызывают друг друга последовательно, чтобы превратить первоначально поданные данные в иные формы. Переменные в этом процессе не модифицируются.
    </p>
    <p class="select">
      Вместо того, чтобы хранить состояние в переменных для выполнения простых операций, сделайте их неизменяемыми: это безопаснее и чище. Код с неизменяемыми переменными намного проще для работы и расширения.
    </p>
    <p class="select">
      Читаемость и производительность кода могут быть лучше при таком подходе. Как находить баланс — отдельная тема, достойная обсуждения.
    </p>
     <h3 class="select first_letter">Рекурсия</h3>
    <p class="select">
      Ещё один способ избежать цикла — это использовать <u>рекурсию</u>.
    </p>
    <p class="select">
      Рекурсия проста в исполнении. Создаёте функцию, которая вызывает саму себя (создавая тем самым цикл), добавляете условие выхода.
    </p>
    <p class="select">
      Не факт, что рекурсию можно отнести к декларативному стилю, но это как минимум альтернатива обычному циклу. Также, рекурсия может быть менее производительна, код менее читаемым.
    </p>
    <p class="select">
      Иногда рекурсия — лучший способ решить задачу, и мы можем обойти её, воспользовавшись стеком (это несложно).
    </p>
    <h3 class="select">Задача. Вычислить сумму чисел в массиве.</h3>
    <p class="select">
      Пример написания простой программы без использования условного оператора for. Красиво, модно, молодежно! 😉
    </p>
    <p class="select">
      Предположим, у нас есть массив чисел наподобие следующего:
    </p>
    
            <code>
              <pre class="select">
              <font face="Verdana">const mass = [17, -4, 3.2, 8.9, -1.3, 0, Math.PI];</font>
              </pre>
            </code>
    
    <p class="select">Решение с циклом:</p>
    <blockquote>
            <code>
              <pre class="select">
              <font face="Verdana">
let sum = 0;
mass.forEach((number) => {
sum += number;
});
console.log(sum);
</font>
              </pre>
            </code>
    </blockquote>
    <p class="select"> Здесь мы для достижения результата постоянно изменяем переменную sum.</p>
     <p class="select">Вот решение, использующее прекрасную функцию reduce:</p>
    <blockquote>
            <code>
              <pre class="select">
               <font face="Verdana"> 
const sum = mass.reduce((acc, number) =>
acc + number
);
console.log(sum);
</font>
              </pre>
            </code>
    </blockquote>
    <p class="select">Промежуточные состояния нигде не перезаписываются. Вместо этого, мы сделали множество вызовов функции, а состояние передавалось между этими вызовами до конечного присваивания к sum.</p>
    <p class="select">А вот решение с применением рекурсии:</p>
    <blockquote>
            <code>
              <pre class="select">
<font face="Verdana">                
const sum = ([number, ...rest]) => {
if (rest.length === 0) { 
return number;
}
return number + sum(rest);
};
console.log(sum(mass))
</font>
              </pre>
            </code>
    </blockquote>
<p class="select">Функция sum вызывает саму себя и использует оператор rest, чтобы уменьшить суммируемый массив. И останавливается, когда массив пуст.</p>
<p class="select">Кому-то может показаться это решение хорошим, но как минимум, оно хуже читается, нежели решение с reduce.</p>
    <h3 class="select first_line">Итог</h3>
    <p class="select">Все решения, предложенные здесь, основаны на функциях map, filter и reduce. Они позволяют совершать очень много крутых приёмов! Читайте о них больше, пробуйте применять на практике.</p>
    <img class="start_img" src="https://proglib.io/wp-content/uploads/-000//1/CubirbWWAAA0Xpu.jpg">
  </div>
</body>
</html>